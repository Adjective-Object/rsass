//! Tests auto-converted from "sass-spec/spec"
//! version 58c39e1a, 2021-04-28 16:19:08 -0500.
//! See <https://github.com/sass/sass-spec> for source material.\n
//! The following tests are excluded from conversion:
//! ["core_functions/selector/extend", "core_functions/selector/is_superselector", "core_functions/selector/unify", "directives/extend", "directives/forward", "libsass-closed-issues/issue_185/mixin.hrx", "libsass-todo-issues/issue_221262.hrx", "libsass-todo-issues/issue_221260.hrx", "libsass-todo-issues/issue_221292.hrx", "libsass/unicode-bom/utf-16-big", "libsass/unicode-bom/utf-16-little", "non_conformant/scss/huge.hrx", "non_conformant/scss/mixin-content.hrx", "non_conformant/scss/multiline_var.hrx"]
use rsass::output::Format;
use rsass::{parse_scss_file, Error, FsFileContext, FileContext, ScopeRef};
use std::collections::BTreeMap;

struct TestRunner {
    format: Format,
    file_context: TestFileContext,
}

#[derive(Clone, Debug)]
struct TestFileContext {
    parent: FsFileContext,
    mock: BTreeMap<String, String>,
}

impl TestFileContext {
    fn new() -> Self {
        let mut parent = FsFileContext::new();
        parent.push_path("tests/spec".as_ref());
        TestFileContext {
            parent,
            mock: BTreeMap::new(),
        }
    }
    fn mock_file(&mut self, name: &str, content: &str) {
        self.mock.insert(name.into(), content.into());
    }
}

use std::io::Cursor;
use std::io::Read;

impl FileContext for TestFileContext {
    type File = Cursor<Vec<u8>>;

    fn find_file(&self, name: &str) -> Result<Option<(Self, String, Self::File)>, Error> {
        for name in vec![
            name.to_string(),
            format!("{}.scss", name),
            format!("_{}.scss", name),
            format!("{}/index.scss", name),
            format!("{}/_index.scss", name),
        ] {
            if let Some(data) = self.mock.get(dbg!(&name)) {
                //let path = full.display().to_string();
                /*return match Self::File::open(full) {
                    Ok(file) => Ok(Some((c, path, file))),
                    Err(e) => Err(Error::Input(path, e)),
            };*/
                return Ok(Some((
                    self.clone(),
                    name,
                    Cursor::new(data.as_bytes().to_vec()),
                )))
            }
        }
        Ok(self.parent
            .find_file(name)?
            .map(|(ctx, name, mut file)| {
                let mut buf = Vec::new();
                file.read_to_end(&mut buf).unwrap();
                (
                    TestFileContext { parent: ctx, mock: BTreeMap::new() },
                    name,
                    Cursor::new(buf),
                 )
            }))
    }
}


impl TestRunner {
    fn new() -> TestRunner {
        TestRunner {
            format: Default::default(),
            file_context: TestFileContext::new(),
        }
    }
    fn set_precision(mut self, precision: usize) -> Self {
        self.format = Format {
            precision,
            ..self.format
        };
        self
    }
    fn mock_file(mut self, name: &str, content: &str) -> Self {
        self.file_context.mock_file(name, content);
        self
    }
    fn rsass(&self, input: &str) -> Result<Vec<u8>, Error> {
        let items = parse_scss_file(&mut input.as_bytes(), "input.scss")?;
        self.format.write_root(
            &items,
            ScopeRef::new_global(self.format),
            &self.file_context,
        )
    }
    fn ok(&self, input: &str) -> String {
        match self.rsass(input) {
            Ok(css) => String::from_utf8(css).unwrap().replace("\n\n", "\n"),
            Err(err) => panic!("Unexpected error:\n{}\n", err),
        }
    }
    fn err(&self, input: &str) -> String {
        match self.rsass(input) {
            Ok(css) => panic!(
                "Unexpected result:\n{}\n",
                String::from_utf8(css).unwrap()
            ),
            Err(err) => err.to_string(),
        }
    }
}

mod arguments;

mod core_functions;

mod css;

mod directives;

mod expressions;

mod libsass;

mod libsass_closed_issues;

mod libsass_todo_issues;

mod libsass_todo_tests;

mod non_conformant;

mod parser;

mod values;
